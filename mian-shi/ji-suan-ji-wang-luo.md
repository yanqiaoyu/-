# 计算机网络

## 1. 讲一讲HTTP与HTTPS

从**定义**入手，http是什么，是超文本传输协议Hyper Text Transfer Protocol。这是一个基于TCP/IP协议进行数据传输的协议，一般用于B/S架构下进行数据传输

那么他有什么**特性**呢？特性主要如下，

* 客户端在请求服务的时候，简单快速，只需传送**请求方法**和资源**路径（在这里可以补充常见的请求方法，比如说get post head）**
* 请求内容非常灵活，通过**Content Type**这个字段，我们可以传送任意类型的数据（可能会让补充content type有哪些：举例，以text开头的一些文本格式，以image开头的一些图片格式，以application开头的一些媒体文件格式）
* http的请求是**无连接**的，也就是一次tcp握手连接，处理一个请求，处理完毕后便关闭了该连接。但是这样做不利于服务器与客户端保持连接，所以还引入了cookies和seesion
* http请求也是**无状态**的，即后面的会话如果要处理之前的信息，需要重新上传该信息

那我们为什么要引入https呢，是为了解决一些http的**安全隐患**，比方说

* 数据是明文传输，不安全
* 不会对传输的数据进行校验，存在被篡改的风险
* 不会校验身份，可能被冒充身份

那https什么，其实就是http + ssl/tls,，即通过ssl证书来协助完成数据交互的身份验证与加密来确保安全当然，https也存在部分安全隐患，比方说中间人攻击

其实fiddler的工作原理就是中间人攻击

我理解是这样：Fiddler站在浏览器和服务器之间，抓包时，浏览器发出请求实质是向Fiddler发出请求，因此加密解密涉及的密钥两者都是知道的，Fiddler当然就可以将数据解码。Fiddler收到浏览器的请求信息后，用Fiddler和服务器之间的密钥来对信息进行加密再传送，这些加密后的信息就只有Fiddler和服务器才能解密了。所以这一抓包的过程并没有什么破解的行为在里面。倘若一个不知情的人获取了这些加密的信息，他是无法破解这些加密的信息的，因为他不知道密钥。

## 2. HTTP常见的状态码有哪些？

* 以1开头：指示客户端继续请求，比方说100
* 以2开头：客户端请求成功或者完成，比方说200
* 以3开头：重定向，需要进一步的操作才能完成请求
* 以4开头：客户端错误，比方说400 bad request 404 not found 403 forbidden
* 以5开头：服务端错误，比方说

200 ：请求成功，成功返回网页

 301 ：资源（网页等）被永久转移到其它URL 

302 ：资源（网页等）被临时转移到其它URL 

304 ：请求未修改、命中缓存

401 ：未授权 

403 ：服务器拒绝请求 

404 ：请求的网页或资源不存在 

500 ：内部服务器错误，无法完成请求 

502 ：错误网关 

503 ：请求未完成，服务器临时过载或宕机 

504 ：网关超时



## 3.浏览器输入网址后发生了什么？

建议分成HTTP和HTTPS分开回答

如果是HTTP连接

1. 浏览器解析我们输入的URL，抽出域名字段
2. 尝试进行DNS解析，找到域名对应的IP。先从缓存里面找，比如说浏览器缓存，本地电脑缓存，路由器缓存，ISP缓存，如果还没有找到再去DNS服务器上找
3. 浏览器通过3次握手与服务器建立连接
4. 浏览器发送HTTP请求，
5. 服务器根据需要进行负载均衡并根据请求作出相应的响应
6. 4次挥手释放连接
7. 浏览器根据返回的数据进行html渲染并呈现出相应的页面

如果是HTTPS连接

则在4，5之间多了一些步骤

## 4.浏览器点击刷新后发生了什么？

1. 本质与上面一样，不过不需要抽出域名字段了，而是直接开始DNS缓存的查询

## 5.ping指令的具体过程是什么？

这个问题可以分为相同网段和不同网段来进行讨论

我们假设从主机A ping到 主机B

对于同一网段内的ping来说：

1. 检查A自己是否有B的MAC地址，有的话，ICMP数据包就直接过去了，没有的话，则先要通过ARP广播包获取B的MAC
2. B在收到了这个ARP的广播包之后，会回复一个ARP单播包，告诉A ，B的MAC地址
3. 在A了解了B的地址后，icmp包就能传过去了，ping也就通了

对于不同网段的ping来说：

1. 基本流程与上面一致，但是MAC地址的获取则不太一样。在这里，由于网段不同，A会先去寻找自己的网关，请求网关帮自己转发这个ARP协议

## 6.负载均衡算法有哪些？

多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。

* 轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势
* 随机法：随机获取一台，和轮询类似
* 哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie
* 加权轮询：根据服务器性能不同加权

## 7.什么是DDos？

分布式拒绝服务攻击，比较典型的例子是在TCP第三次握手时，客户端不回复ACK报文，使得服务端存在大量未完整建立连接的客户端队列

解决办法：

1. 减少等待第三次握手的等待时间
2. 减少允许的半连接的数量

## 8. XSS攻击

跨站脚本攻击，就是

## 9.既然有了MAC地址，为什么还需要IP？



## 10.实时视频通讯如何实现，用到什么协议 

应用层用到了RCP/RTCP，传输层则是基于UDP

## 11. 为什么是三次握手，四次挥手？

两次握手会发生什么异常情况？

考虑这样一个异常场景，假设今天客户端发送了两个SYN用以建立连接，其中旧的SYN比新的SYN要先到，那么服务端会回给这个旧的SYN一个SYN+ACK，注意，如果此时只有两次握手，那么这个旧的连接就建立起来了，但实际上我们并不需要这个旧的连接，三次握手就能解决这个问题，客户端在收到了SYN+ACK之后，如果发现这是旧的连接，那么就会发RST来告诉服务端关掉这个连接，如果是正常的连接，则会发ACK给服务端并建立连接

所以三次握手相较两次握手，解决了历史连接被初始化的问题

同样的，由于网络环境较差，一个客户端重复重复发送了很多很多SYN包，而如果服务端每来一个SYN就建立一个连接，会导致资源的浪费，三次握手也能解决这个问题

还有一个原因，就是TCP的连接，在通信时需要维护一个序列号，这个序列号是TCP可靠性的重要保障（去重，保证顺序），那么在第二次握手时，服务端会给客户端发送初始的Seq，只要当客户端响应了这个seq，才能双方的序列号是被可靠的同步了的

那么四次握手行不行呢？可以握，但没必要，因为四次握手指的是服务端发送ACK+SYN与发送同步的Seq分开来发，而实际可以合为一步，因此没必要浪费资源做四次握手

这就是关于三次握手的部分

那么再来讲讲四次挥手，四次挥手可以类比为离职流程

客户端发送一个FIN报文，请求关闭连接，进入FINISH WAIT1阶段（我要离职了，我不会有主动产出，但我可以接收公司最后给我派发的任务）

服务端接收到了FIN报文，会回复一个ACK，但由于服务端可能还有数据需要发送，所以服务端进入了CLOSE WAIT状态

客户端收到了FIN后进入了FINISH\_WAIT2阶段

等到服务器需要发送给客户端的数据发送完成了，服务端发送FIN报文，进入LAST\_ACK 状态，等待客户端的最后一次ACK

客户端，收到了服务端发来的FIN之后，发送ACK，并进入TIME\_WAIT阶段，此时客户端等待两个最大报文存活时间后，自动进入了CLOSE状态，而服务端在收到了ACK之后，就进入了CLOSE状态

那么为什么要等待2个最大报文生存时间呢？

首先这个等待2个MSL Maximum Segment Lifetime ，是在客户端最后一次发送ACK时开始计时的，如果服务端发送了FIN之后，没有收到客户端来的ACK，则会重发这个FIN，这样一来一回刚好2个MSL，所以是为了等待网络中所有包都处理完，避免异常

Linux里面2MSL是60秒

参考 [https://www.zhihu.com/question/271701044](https://www.zhihu.com/question/271701044)

## 12. 2MSL如果过长或者过短会怎么样？

先说说过短的情况

之前由于网络延迟而没有抵达的旧的报文，在某个端口被复用，TCP连接被重新建立起来后，可能抵达了，导致数据顺序错乱

客户端的最后一个ACK发送到服务端后，如果ACK超时了，那么服务端应该要重新发送FIN包，此时如果等待时间过短，会导致服务端处于LAST ACK的状态，这时，如果想重新建立这个连接，服务端则会发送RST，导致连接无法完成建立

参考 [https://www.zhihu.com/question/271701044](https://www.zhihu.com/question/271701044)

## 

