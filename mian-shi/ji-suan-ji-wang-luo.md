# 计算机网络

## 1. 讲一讲HTTP与HTTPS

从**定义**入手，http是什么，是超文本传输协议Hyper Text Transfer Protocol。这是一个基于TCP/IP协议进行数据传输的协议，一般用于B/S架构下进行数据传输

那么他有什么**特性**呢？特性主要如下，

* 客户端在请求服务的时候，简单快速，只需传送**请求方法**和资源**路径（在这里可以补充常见的请求方法，比如说get post head）**
* 请求内容非常灵活，通过**Content Type**这个字段，我们可以传送任意类型的数据（可能会让补充content type有哪些：举例，以text开头的一些文本格式，以image开头的一些图片格式，以application开头的一些媒体文件格式）
* http的请求是**无连接**的，也就是一次tcp握手连接，处理一个请求，处理完毕后便关闭了该连接。但是这样做不利于服务器与客户端保持连接，所以还引入了cookies和seesion
* http请求也是**无状态**的，即后面的会话如果要处理之前的信息，需要重新上传该信息

那我们为什么要引入https呢，是为了解决一些http的**安全隐患**，比方说

* 数据是明文传输，不安全
* 不会对传输的数据进行校验，存在被篡改的风险
* 不会校验身份，可能被冒充身份

那https什么，其实就是http + ssl/tls,，即通过ssl证书来协助完成数据交互的身份验证与加密来确保安全当然，https也存在部分安全隐患，比方说中间人攻击

#### HTTPS 和 HTTP

* HTTPS 协议需要申请证书
* HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443
* HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的
* HTTPS 可以有效的防止运营商劫持



其实fiddler的工作原理就是中间人攻击

我理解是这样：Fiddler站在浏览器和服务器之间，抓包时，浏览器发出请求实质是向Fiddler发出请求，因此加密解密涉及的密钥两者都是知道的，Fiddler当然就可以将数据解码。Fiddler收到浏览器的请求信息后，用Fiddler和服务器之间的密钥来对信息进行加密再传送，这些加密后的信息就只有Fiddler和服务器才能解密了。所以这一抓包的过程并没有什么破解的行为在里面。倘若一个不知情的人获取了这些加密的信息，他是无法破解这些加密的信息的，因为他不知道密钥。

## 2. HTTP常见的状态码有哪些？

* 以1开头：指示客户端继续请求，比方说100
* 以2开头：客户端请求成功或者完成，比方说200
* 以3开头：重定向，需要进一步的操作才能完成请求
* 以4开头：客户端错误，比方说400 bad request 404 not found 403 forbidden
* 以5开头：服务端错误，比方说

200 ：请求成功，成功返回网页

 301 ：资源（网页等）被永久转移到其它URL 

302 ：资源（网页等）被临时转移到其它URL 

304 ：请求未修改、命中缓存

401 ：未授权 

403 ：服务器拒绝请求 

404 ：请求的网页或资源不存在 

500 ：内部服务器错误，无法完成请求 

502 ：错误网关 

503 ：请求未完成，服务器临时过载或宕机 

504 ：网关超时



## 3.浏览器输入网址后发生了什么？

建议分成HTTP和HTTPS分开回答

如果是HTTP连接

1. 浏览器解析我们输入的URL，抽出域名字段
2. 尝试进行DNS解析，找到域名对应的IP。先从缓存里面找，比如说浏览器缓存，本地电脑缓存，路由器缓存，ISP缓存，如果还没有找到再去DNS服务器上找
3. 浏览器通过3次握手与服务器建立连接
4. 浏览器发送HTTP请求，
5. 服务器根据需要进行负载均衡并根据请求作出相应的响应
6. 4次挥手释放连接
7. 浏览器根据返回的数据进行html渲染并呈现出相应的页面

如果是HTTPS连接

则在4，5之间多了一些步骤

## 4.浏览器点击刷新后发生了什么？

1. 本质与上面一样，不过不需要抽出域名字段了，而是直接开始DNS缓存的查询

## 5.ping指令的具体过程是什么？

这个问题可以分为相同网段和不同网段来进行讨论

我们假设从主机A ping到 主机B

对于同一网段内的ping来说：

1. 检查A自己是否有B的MAC地址，有的话，ICMP数据包就直接过去了，没有的话，则先要通过ARP广播包获取B的MAC
2. B在收到了这个ARP的广播包之后，会回复一个ARP单播包，告诉A ，B的MAC地址
3. 在A了解了B的地址后，icmp包就能传过去了，ping也就通了

对于不同网段的ping来说：

1. 基本流程与上面一致，但是MAC地址的获取则不太一样。在这里，由于网段不同，A会先去寻找自己的网关，请求网关帮自己转发这个ARP协议

## 6.负载均衡算法有哪些？

多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。

* 轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势
* 随机法：随机获取一台，和轮询类似
* 哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie
* 加权轮询：根据服务器性能不同加权

## 7.什么是DDos？

分布式拒绝服务攻击，比较典型的例子是在TCP第三次握手时，客户端不回复ACK报文，使得服务端存在大量未完整建立连接的客户端队列

解决办法：

1. 减少等待第三次握手的等待时间
2. 减少允许的半连接的数量

## 8. 讲讲CSRF攻击以及XSS攻击

CSRF，跨站请求伪造，主要攻击的步骤如下：

1. 用户访问了一个网站A，留下了cookie
2. 用户再访问了一个网站B，网站B伪造了一个访问网站A的请求，如果此时网站A没有做相关防护，那么攻击就成功了

防范方法：

token验证，服务端下发一个token给客户端，要求客户端提交表单的时候，携带这个token

refer验证，意思是只接受本网站的请求，不是则拦截

那么什么是XSS呢，跨域脚本攻击

攻击的方式主要就是在页面中注入攻击脚本，可能是js或者html代码块，使得用户在访问该网页时，不自觉的执行了攻击者想要我们执行的操作

主要防范方法，针对特定输入，进行转义

## 9.既然有了MAC地址，为什么还需要IP？

我认为这个问题的本质与，有了IP为什么还需要MAC是差不多的，都是希望把MAC或者IP当成唯一标示，来指导数据的传输

原因有3

第一，包在传输的过程中，目的MAC是会变的，起到了记录下一跳的作用，而IP地址则记录了信息的终点，是不会变的

第二，如果只靠MAC地址，没有IP地址，那么包在经过路由器的时候，需要针对每一个MAC维护一个很大的路由表，这是不现实的，而有了IP地址，我们可以根据IP的子网，进行转发，大大的提高了效率

第三，网络是分层实现的，MAC在数据链路层，IP在网络层，这样子的设计使得协议之间的转换可以更为迅捷

## 10. 那能不能只要IP不要MAC呢？

也不行，在设备获取到IP之前，需要用到MAC地址作为唯一标识，来区分不同的设备，保证能正常地获取IP

## 10.实时视频通讯如何实现，用到什么协议 

应用层用到了RCP/RTCP，传输层则是基于UDP

## 11. 为什么是三次握手，四次挥手？

两次握手会发生什么异常情况？

考虑这样一个异常场景，假设今天客户端发送了两个SYN用以建立连接，其中旧的SYN比新的SYN要先到，那么服务端会回给这个旧的SYN一个SYN+ACK，注意，如果此时只有两次握手，那么这个旧的连接就建立起来了，但实际上我们并不需要这个旧的连接，三次握手就能解决这个问题，客户端在收到了SYN+ACK之后，如果发现这是旧的连接，那么就会发RST来告诉服务端关掉这个连接，如果是正常的连接，则会发ACK给服务端并建立连接

所以三次握手相较两次握手，解决了历史连接被初始化的问题

同样的，由于网络环境较差，一个客户端重复重复发送了很多很多SYN包，而如果服务端每来一个SYN就建立一个连接，会导致资源的浪费，三次握手也能解决这个问题

还有一个原因，就是TCP的连接，在通信时需要维护一个序列号，这个序列号是TCP可靠性的重要保障（去重，保证顺序），那么在第二次握手时，服务端会给客户端发送初始的Seq，只要当客户端响应了这个seq，才能双方的序列号是被可靠的同步了的

那么四次握手行不行呢？可以握，但没必要，因为四次握手指的是服务端发送ACK+SYN与发送同步的Seq分开来发，而实际可以合为一步，因此没必要浪费资源做四次握手

这就是关于三次握手的部分

那么再来讲讲四次挥手，四次挥手可以类比为离职流程

客户端发送一个FIN报文，请求关闭连接，进入FINISH WAIT1阶段（我要离职了，我不会有主动产出，但我可以接收公司最后给我派发的任务）

服务端接收到了FIN报文，会回复一个ACK，但由于服务端可能还有数据需要发送，所以服务端进入了CLOSE WAIT状态

客户端收到了FIN后进入了FINISH\_WAIT2阶段

等到服务器需要发送给客户端的数据发送完成了，服务端发送FIN报文，进入LAST\_ACK 状态，等待客户端的最后一次ACK

客户端，收到了服务端发来的FIN之后，发送ACK，并进入TIME\_WAIT阶段，此时客户端等待两个最大报文存活时间后，自动进入了CLOSE状态，而服务端在收到了ACK之后，就进入了CLOSE状态

那么为什么要等待2个最大报文生存时间呢？

首先这个等待2个MSL Maximum Segment Lifetime ，是在客户端最后一次发送ACK时开始计时的，如果服务端发送了FIN之后，没有收到客户端来的ACK，则会重发这个FIN，这样一来一回刚好2个MSL，所以是为了等待网络中所有包都处理完，避免异常

Linux里面2MSL是60秒

参考 [https://www.zhihu.com/question/271701044](https://www.zhihu.com/question/271701044)

为什么是四次挥手呢？因为在三次握手中，服务端的ACK和SYN是一起发送的，

而在四次挥手中，客户端主动发送了FIN报文后，服务端会先回一个ACK，等服务端处理完要发送的信息，才会发送FIN，因此四次挥手多就是多在这一步

## 12. 2MSL如果过长或者过短会怎么样？

先说说过短的情况

之前由于网络延迟而没有抵达的旧的报文，在某个端口被复用，TCP连接被重新建立起来后，可能抵达了，导致数据顺序错乱

客户端的最后一个ACK发送到服务端后，如果ACK超时了，那么服务端应该要重新发送FIN包，此时如果等待时间过短，会导致服务端处于LAST ACK的状态，这时，如果想重新建立这个连接，服务端则会发送RST，导致连接无法完成建立

参考 [https://www.zhihu.com/question/271701044](https://www.zhihu.com/question/271701044)

## 13.TCP UDP区别

TCP是有连接的，可靠的，面向流的

UDP是无连接的，不可靠的，面向报文的

## 14. OSI

OSI 七层 应表会 传 网 数物 （应用层 表示层 会话层 传输层 网络层 数据链路层 物理层）

对应了TCP/IP的四层分别为 （          应用层               传输层  网际层      网络接口层）

## 15.微信用的是TCP还是UDP

视频聊天用的是UDP，文字图片等用的是TCP

## 16.为什么说HTTPS是安全的？

先说说HTTP为什么不安全

HTTP是明文传输，抓个包就能知道报文的信息

HTTP不验证通信双方的身份，可能被伪装

HTTP不验证报文的完整性，可能遭遇篡改

总结一下就是，通信不加密，可能被窃听，身份不验证，可能被伪装，报文不验证完整，可能被篡改

（抓包，伪装，篡改）

那么HTTPS针对上面的问题做出了什么样的改进呢？

针对通信不加密的问题，采用了对称加密+非对称加密的方式，即秘钥交换阶段用非对称加密，通信阶段用对称加密的方式保证安全

针对报文可能被篡改的问题，采用了在数据包中添加数字签名的方法来保证安全

针对身份可能被伪装的问题，采用了第三方的CA证书的方式保证安全

{% embed url="https://juejin.im/entry/5cc270675188252d6809c6d3" %}

## 17.GFW的原理

关键字过滤：出现了特定的关键字之后，往通信双方发送RST报文，阻断连接

IP地址封锁

特定端口封锁

DNS劫持

SSL阻断连接

深入一点就是往双方发RST，阻断TCP连接的建立

## 18. 验证码应该放在客户端还是服务端，说说原因

一般放在session里面

放在session中，session的作用域在一次会话中，用户开一个浏览器访问一个网站，只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，或者服务器关闭，这整个过程我们称作一次会话。那及时在不同的请求中，我们都可以得到验证码的信息。得到验证码的信息我们就可以判断用户输入的是否正确 

## 19. 不同的HTTP版本有什么区别？

{% embed url="https://juejin.im/post/5d5fe4cb51882569d64b9228" %}

HTTP 0.9 ，非常简单的版本，只支持GET请求方式，不存在请求头这个概念，只能完成很简单的交互

HTTP1.0，新增了请求方法，比如说POST HEADE等方法，新增了请求头和响应头这个概念，拓展了传输内容的格式，可以传输音频视频图片等多媒体信息，此时的HTTP是无状态，无连接的。无连接会导致两种缺陷，一种是TCP连接无法复用，浪费资源，另一种是队头可能阻塞，前一个阻塞了，后面的也无法继续进行

**HTTP1.1，针对HTTP1.0做出了一些改善，比如说新增了Connection字段，使得HTTP可以复用TCP连接，不需要不停的创建新的TCP连接了，还有缓存处理cache control字段，以及断点续传**

HTTP2.0，主要的特性有，二进制分帧，多路复用，压缩消息头，

## 20. GET POST区别？

这个问题我想分成两个方面来回答

第一个方面，从使用的区别来说

get发送消息，数据在header或者cookie中，而post的数据存在body中

get传数据，长度可能收到浏览器设定的限制，而post则没有这种困扰

get相对于post较不安全，因为get的数据放在url中

get请求资源，浏览器会一次性发送header和data，服务器返回200，而post则会先发送header，服务器返回100 continue之后，在发送data

第二个方面，从本质来说，GET是幂等的，即每一次的请求都具有相同的副作用，而POST则不是，因此在需要增删改的场景使用GET是非常危险的。

