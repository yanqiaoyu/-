# Python相关

## 1.讲讲迭代器/生成器/装饰器

迭代器：

这里我们先来回顾一下**什么是可迭代对象（Iterable）**？

可以**直接作用于for循环的对象**统称为**可迭代对象**，即Iterable。 　　\# 一是集合数据类型，如list、tuple、dict、set、str等； 　　\# 二是generator，包括生成器和带yield的generator function。

那么**什么又是迭代器（Iterator）？**

可以**被next\(\)函数调用**并**不断返回下一个值**（直到**没有数据时抛出StopIteration错误**）的对象称为迭代器，即Iterator。

生成器：

使用了 yield 的函数被称为生成器（generator）生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。

装饰器：

返回值是函数的高阶函数，当我们不想修改某个func里面的源码的时候，就可以为这个func添加一个修饰器，主要的应用场景有 添加日志，打印程序执行时间，缓存，权限校验等

## 2.讲讲xrange与range的区别？

首先要说明，只有在Python2中才有xrange与range这两个函数了，在Python3中只剩下了range

Python2中的range返回的是一个列表，而xrange返回的是一个生成器，Python3中的range其实就是Python2里面的xrange，这样做的好处是，如果今天需要遍历一个很大的列表，那么如果直接返回这个列表会占用很大的空间，而返回生成器则会大大节省资源

## 3.讲讲 return和yield的区别

return：在程序函数中返回某个值，返回之后函数不在继续执行，彻底结束。

yield: 带有yield的函数是一个生成器，函数返回某个值时，会停留在某个位置，返回函数值后，会在前面停留的位置继续执行，直到程序结束 next（foo（））或者foo（）。next（）这样才会继续执行

## 4.讲讲 \_\_init\_\_和\_\_new\_\_的区别

[\_\_new\_\_和\_\_init\_\_的区别，说法正确的是](https://www.nowcoder.com/profile/701230/myFollowings/detail/5726157)？ （**ABCD**）

A. \_\_new\_\_是一个静态方法，而\_\_init\_\_是一个实例方法

B. \_\_new\_\_方法会返回一个创建的实例，而\_\_init\_\_什么都不返回

C. 只有在\_\_new\_\_返回一个cls的实例时，后面的\_\_init\_\_才能被调用

D. 当创建一个新实例时调用\_\_new\_\_，初始化一个实例时用\_\_init\_\_



* \_\_new\_\_是在实例创建**之前**被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。
* \_\_init\_\_是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法。

## 5.讲讲 not a in b的优先级

显然，如果我们操作过字典的话，就能知道 先计算 a in b，再计算 if not 

## 6. 讲一讲python的内存管理机制

python的底层也是通过malloc和free来申请和释放内存的，因此python有自己的一套内存管理机制来代替程序员决定什么时候释放或者申请内存，同时也开放了一些接口给我们进行手动的申请和释放。

python的内存管理主要由两部分组成：引用计数与垃圾回收，前者确定当前变量是否需要释放，后者解决前者解决不了的循环引用问题，以及提供手动释放的接口

先讲讲引用计数，python中每个对象都有一个计算指向该对象的引用计数器，多一个引用就+1，少一个引用就-1，当引用计数归0时，先判断在不在缓冲区中，如果在则不会被释放，而是等待下一次的使用，不在的话则立即释放

还有一个垃圾回收机制，用以解决引用计数无法解决的循环引用或者自己引用了自己的问题。这种情况下，可能已经没有变量指向了某个对象，但这个对象的引用计数器仍大于0，导致无法被引用计数机制回收。这种时候就需要

## 7. Python的深拷贝与浅拷贝

浅拷贝 是 copy.copy\(\), a和b是两个独立的对象，但是子对象还是引用，比如说列表里面还有列表

深拷贝则是完全独立的两个变量



